## Lesson Aims:
* Be able to describe and apply the following to linear queues, circular queues and priority queues:
  * add an item
  * remove an item
  * test for an empty queue
  * test for a full queue
* Be able to:
  * represent a queue in a programming languange without using the built in queue type
  * use a queue in simple contexts

---
## Common Features of Queues
All queues have the following features in common:
* They are all **F**irst **i**n **F**irst **O**ut **(FIFO)** data structures
* An *Enqueue* method:
  * This method takes a data item and adds it to the rear of the queue
* A *Dequeue* method:
  * This method takes no arguments and removes the item that is at the front of the queue and returns it
* They all have two pointers
  * *Front*: This pointer shows the item to remove when *Dequeue* is called
  * *Rear*: This pointer shows where the rear of the queue is *Enqueue* is called. 
---
## Linear Queues
**Enqueue**
```python
# Enqueue Method using OOP
def Enqueue(self, data):
    # If the rear pointer is equal to the size of the queue
    # The queue must be full.
    if self.rear == self.size:
        print("The Queue is full")
    # The queue is not full, so we increment the rear pointer
    # to point to the next available free space and add the
    # data item.
    else:
        self.rear += 1
        self.queue[self.rear]
```
**Dequeue**
```python
# Dequeue Method using OOP
def Dequeue(self):
    # If the rear pointer is greater than or equal to the front pointer
    # the queue must be empty.
    if self.rear >= self.front:
        print("The Queue is empty")
    # Otherwise, if the queue is not empty, there must be an element to
    # return. We do this by returning the element at the index that front
    # points to, and then incrementing front to point to the next element
    # at the head of the queue.
    else:
        return self.queue[self.front]
        front += 1
```
