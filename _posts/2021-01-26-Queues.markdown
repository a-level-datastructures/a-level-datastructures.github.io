## Lesson Aims:
* Be able to describe and apply the following to linear queues, circular queues and priority queues:
  * add an item
  * remove an item
  * test for an empty queue
  * test for a full queue
* Be able to:
  * represent a queue in a programming languange without using the built in queue type
  * use a queue in simple contexts

---
## Common Features of Queues
All queues have the following features in common:
* They are all **F**irst **i**n **F**irst **O**ut **(FIFO)** data structures
* An *Enqueue* method:
  * This method takes a data item and adds it to the rear of the queue
* A *Dequeue* method:
  * This method takes no arguments and removes the item that is at the front of the queue and returns it
* They all have two pointers
  * *Front*: This pointer shows the item to remove when *Dequeue* is called
  * *Rear*: This pointer shows where the rear of the queue is *Enqueue* is called. 
---
## Linear Queues
**Enqueue**
```python
# Enqueue Method using OOP
def Enqueue(self, data):
    if self.isFull():
        print("The Queue is full")
    # The queue is not full, so we increment the rear pointer
    # to point to the next available free space and add the
    # data item.
    else:
        self.rear += 1
        self.queue[self.rear]
```
**Dequeue**
```python
# Dequeue Method using OOP
def Dequeue(self):
    if self.isEmpty():
        print("The Queue is empty")
    # Otherwise, if the queue is not empty, there must be an element to
    # return. We do this by returning the element at the index that front
    # points to, and then incrementing front to point to the next element
    # at the front of the queue.
    else:
        return self.queue[self.front]
        front += 1
```
